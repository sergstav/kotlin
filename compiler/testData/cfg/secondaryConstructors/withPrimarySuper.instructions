== B ==
open class B(x: Int)
---------------------
L0:
  1 <START>
    v(x: Int)
    magic[FAKE_INITIALIZER](x: Int) -> <v0>
    w(x|<v0>)
L1:
    <END>                                      NEXT:[<SINK>]
error:
    <ERROR>                                    PREV:[]
sink:
    <SINK>                                     PREV:[<ERROR>, <END>]
=====================
== A ==
class A(val w: Char, u: Int = 2) : B(w.toInt() + u) {
    val x: Int
    var y: Int
    val z: Int
    val v = -1

    constructor(): this('a') {
        y = 2
    }

    // anonymous
    constructor {
        x = w
        z = 8
    }

    constructor(a: Int, b: Int = 3): this(b.toChar()) {
        y = x
    }

    // anonymous
    constructor {
        y = 9
    }
}
---------------------
L0:
  1 <START>
    v(val w: Char)
    magic[FAKE_INITIALIZER](val w: Char) -> <v0>
    w(w|<v0>)
    v(u: Int = 2)
    jmp?(L2)                                         NEXT:[magic[FAKE_INITIALIZER](u: Int = 2) -> <v2>, r(2) -> <v1>]
    r(2) -> <v1>
L2 [after default value for parameter u]:
    magic[FAKE_INITIALIZER](u: Int = 2) -> <v2>      PREV:[jmp?(L2), r(2) -> <v1>]
    merge(u: Int = 2|<v1>, <v2>) -> <v3>
    w(u|<v3>)
    mark(w.toInt())
    r(w) -> <v4>
    mark(toInt())
    call(toInt(), toInt|<v4>) -> <v5>
    r(u) -> <v6>
    mark(w.toInt() + u)
    call(w.toInt() + u, plus|<v5>, <v6>) -> <v7>
    mark(B(w.toInt() + u))
    call(B(w.toInt() + u), <init>|<v7>) -> <v8>
    v(val x: Int)
    v(var y: Int)
    v(val z: Int)
    v(val v = -1)
    r(1) -> <v9>
    mark(-1)
    call(-1, minus|<v9>) -> <v10>
    w(v|<v10>)
  2 mark({ x = w z = 8 })
    magic[IMPLICIT_RECEIVER](x) -> <v11>
    magic[IMPLICIT_RECEIVER](w) -> <v12>
    r(w|<v12>) -> <v13>
    w(x|<v11>, <v13>)
    magic[IMPLICIT_RECEIVER](z) -> <v14>
    r(8) -> <v15>
    w(z|<v14>, <v15>)
    mark({ y = 9 })
    magic[IMPLICIT_RECEIVER](y) -> <v17>
    r(9) -> <v18>
    w(y|<v17>, <v18>)
  1 jmp?(L3, L4)                                     NEXT:[r('a') -> <v20>, v(a: Int), jmp(L5)]
    jmp(L5)                                          NEXT:[<END>]
L3 [before secondary constructor delegating to this]:
    r('a') -> <v20>                                  PREV:[jmp?(L3, L4)]
    mark(this('a'))
    call(this('a'), <init>|<v20>) -> <v21>
  2 mark({ y = 2 })
    magic[IMPLICIT_RECEIVER](y) -> <v22>
    r(2) -> <v23>
    w(y|<v22>, <v23>)
  1 jmp(L5)                                          NEXT:[<END>]
L4 [before secondary constructor delegating to this]:
    v(a: Int)                                        PREV:[jmp?(L3, L4)]
    magic[FAKE_INITIALIZER](a: Int) -> <v25>
    w(a|<v25>)
    v(b: Int = 3)
    jmp?(L6)                                         NEXT:[magic[FAKE_INITIALIZER](b: Int = 3) -> <v27>, r(3) -> <v26>]
    r(3) -> <v26>
L6 [after default value for parameter b]:
    magic[FAKE_INITIALIZER](b: Int = 3) -> <v27>     PREV:[jmp?(L6), r(3) -> <v26>]
    merge(b: Int = 3|<v26>, <v27>) -> <v28>
    w(b|<v28>)
    mark(b.toChar())
    r(b) -> <v29>
    mark(toChar())
    call(toChar(), toChar|<v29>) -> <v30>
    mark(this(b.toChar()))
    call(this(b.toChar()), <init>|<v30>) -> <v31>
  2 mark({ y = x })
    magic[IMPLICIT_RECEIVER](y) -> <v32>
    magic[IMPLICIT_RECEIVER](x) -> <v33>
    r(x|<v33>) -> <v34>
    w(y|<v32>, <v34>)
L1:
L5 [after all secondary constructors delegating to this]:
  1 <END>                                            NEXT:[<SINK>]                                                         PREV:[jmp(L5), jmp(L5), w(y|<v32>, <v34>)]
error:
    <ERROR>                                          PREV:[]
sink:
    <SINK>                                           PREV:[<ERROR>, <END>]
=====================
